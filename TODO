TODO
----

* Show LUA error
* Parse DB in order

SONG INFO SERVER

calls:

add_favorite <path> <userid>
remove_favorite <path> <userid>
played_song <path> <userid>
<userid> = login <handle> <pass>

<stats> = get_stats <path>

get_list <listname> <lastdate>

operation:

Random userid generated by client on first run, used directly
Client can log in (register) to get a permanent id. 



PARTY MODE
----------

Tween probs: Pause and party red
release lock after song end wven if no new song
subsong++ -- when song not switched...


2 second grace only allows sub song?
only applies to songs started with ENTER



v1 SIMPLE
* Song must play for at least 60 seconds before new song can be selected, unless ALT is held


ALWAYS
* Queue remains with ENTER 






Own lock for fft 

SUBSONG does not work after ending in
USF64

Silence at start should have higher threshhold




DC and DS needs to rename libnames to lowercase




* Subtitle in USF64 (and dreamcast?)
* Old info returns if song cant be played
* position next info to right edge
* larger sizes on larger screen

* subsong grouping... RSN vs USF64 for instance.. search on subsongs?





----------------

BUGS

* PI cant always keep up with fft audio
* PI jerky scroll, high cpu when more than ~15 texts on search screen?

* Dont index secondary files
* Dont duplicate fonts
* openmpt type name too long
* Freeze when starting mods?
* Speed up inc search? Remember last set?

FX

* Scroll screens (& stars) left right
* Scroll stars up/down with playlist scrolling


GUI

* Edit playlist screen
* KEY brings up EDITOR of CURRENT list
* Can save to any list name and replaces old
* Find show playlist hits first

TABLE playlist
 NAME INDEX

TABLE plmapping
 PLINDEX IDX SONGINDEX




LUA

* Return/Input VECTOR = Table
*


pl = find('stardust memories')
play(pl)


InfoScreen.add('Hello')

function InfoScreen.add(text, x, y, scale, color)
	infoscreen_add(text, x, y, scale_color);
end


playlist.mt = {}

function Playlist.new()
	local pl = {}
	setmetatable(pl, Playlist.mt)
	return pl
end





struct SongData {
	string title;
	string composer;
	string format;
	string source;
	string url;
	uint64_t uniqueid;

};


class SongSequence {
	int count();
	SongData operator[](int index);
};

class SongList {


class InfoScreen {

	struct InfoText {
		std::string text;
		int x;
		int y;
		uint32_t color;
		float alpha;
		float size;
	}

	shared_ptr<InfoText> add_text(const std::string &text, int x, int y, Font &font, uint32_t color, float size)

	std::vector<std::shared_ptr<InfoText>> texts;

};


auto t = screen.add_text();

tween(t.x




class CommandParser {
public:
	typedef std::function<void(const std::vector<std::string> &args)> Function;

	struct Command {
		std::string name;
		Function callback;
	};

	CommandParser() {
		defineType('i', [](std::string &arg) -> bool {
			stoi(arg);
			return true;
		});
	}

	void defineType(char c, std::function<bool(std::string &arg)> verifier);

	void add(const std::string &name, const std::string &desc, Function f);

	vector<Command> matchCommands(const std::string &line);

	void applyCommand(const Command &cmd, const std::vector<std::string> &args);


	void parse(const std::string &line) {
/*
		auto parts = split(line);
		if(parts.size() < 1)
			return true;

		vector<Command*> foundCommands;

		int l = parts[0].length();
		for(auto &c : commands) {
			if(c.name.substr(l) == parts[0]) {
				foundCommands.push_back(&c);
			}
		}

		if(foundCommands.size() == 1) {
			for(int i=1; i<parts.size(); i++) {
				char c = command.args[i-1].type;
				auto verifier = types[c].verifier;
				verifier(parts[i]);
			}
			foundCommands[0].callback(parts);
		} else {
			for(auto &c : foundCommands) {
			}
		}*/
	}

};
